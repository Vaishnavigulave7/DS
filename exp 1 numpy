# **Experiment No. 1 : Implementation of array operations using Numpy**
## Import required packages
import numpy as np
## Numpy Array
### Creating an 1D Array
arr1D=np.array([1,2,3,4,5,6])
print(arr1D)
### Creating 2D Array


arr2D=np.array([[1,2,3],[4,5,7]])
arr2D
### Creating 3D Array
arr3D= np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
arr3D
### Accessing elements of 1D, 2D and 3D array



#1D array
for i in range(len(arr1D)):
  print(arr1D[i])
#2D array
'''for accessing elements from 2D array, we need to specify row and column
inside [row][column] respectively.'''

for i in range(0,2):            #since we have 2 rows in arr2D
  for j in range(0,3):          #since we have 3 columns in arr2D
    print(arr2D[i][j],end=' ')
  print("\n")

#3D array
'''for accessing elements from 3D array, we need 3 parameters,
plane, row and column. 
syntax:
        array_name[plane][row][column]'''

for i in range(0,2): 
  print(f'Plane {i}\n')           #since we have 2 planes in arr3D
  for j in range(0,2):            #since we have 2 rows in arr3D in each plane
    for k in range(0,3):          #since we have 3 columns in arr3D in each plane
      print(arr3D[i][j][k],end=' ')
    print('\n')
  print('\n')
### Changing elements of 1D, 2D and 3D array
#1D array

array1D=np.array([12,22,32,42,52,62])

#changing 4th element of array1D i.e. 42 with 92
array1D[3]=92

#show changes
print(array1D)
#2D array

array2D=np.array([[12,22,32],
                 [42,52,62]])

#changing element from 2nd row and 2nd column i.e. 52 with 92
array2D[1][1]=92

#show changes
print(array2D)
#3D array

array3D=np.array([[[10,20,30],
                   [40,50,60]],
                  [[70,80,90],
                  [100,110,120]]])

#changing element from 1st plane, 2nd row and 2nd column i.e. 50 with 45 
array3D[0][1][1]=45

#show changes
print(array3D)
#replace all occurances

arr=np.arange(1,50,dtype=int)
arr=arr.reshape(7,7)
print('Before : \n',arr)

#replace all occurances of numbers divisible by 7 with 0
arr[arr%7==0]=0
#we are using boolean expression to replace values
print('After : \n',arr)
## NumPy Array Operations



### arange( )
>This function is used to create array with evenly spaced values

```
np.arange(start,stop,step,dtype)
```
#create array of values from 10 to 50 with step value of 3
arr1=np.arange(10,50,3,dtype=int)
print(arr1)
### zeros( )
>This function is used to create array with all zeroes


```
np.zeros(shape, dtype, order)
```


arr2=np.zeros((3,3),dtype=int, order='C')     #order 'C' refers to row-major i.e. C style memory allocation
print(arr2)
### ones( )
> This function is used to create array with all ones

```
np.ones(shape, dtype, order)

```


arr3=np.ones((3,3),dtype=int,order='F')     #order 'F' refers to column-major i.e. Fortran style memory allocation
print(arr3)
### identity( )
>This function is used to create 2D array of 'n' size with diagonal 1 and 0 elsewhere i.e. identity matrix

```
np.identity(size,dtype)
```


arr4=np.identity(4,dtype=int)
print(arr4)
### eye( )
> This function is used to create 2D array with diagonal 1 and 0 elsewhere similar to identity() but here we can give each dimension separately.

```
np.eye(row, column, diagonal-start, dtype, order)
```


arr5=np.eye(4,5,1,dtype=int,order='C')
print(arr5)

### empty( )
> This function is used to create an uninitialized array of specified shape and data type
```
np.empty(shape,dtype,order)
```
arr6=np.empty((3,3),dtype=int)
print(arr6)
### full( )
>This function is used to create a new array of a specified shape and type, and fills it with a specified value.
```
np.full(shape, fill_value, dtype=None, order='C', *, like=None)
```
arr7=np.full((2,2),3,dtype=int)
print(arr7)
arr8=np.full_like(arr7,9)
arr8
### ndim( )
>It is a function in the NumPy library that returns the number of dimensions of a given NumPy array
```
numpy.ndim(array)
```
arr9=np.array([[12,23,34,45],[76,56,45,43]])
print(arr9)
print(f"\nNo. of dimensions : {np.ndim(arr9)}")

### append( )
> It is a function in the NumPy that appends values to the end of an array

# Create a 1-dimensional array
arr10 = np.array([1, 2, 3])
print(arr10)
# Append a single value to the end of the array
arr10 = np.append(arr10, 4)
print(arr10)
# Append multiple values to the end of the array
arr10 = np.append(arr10, [5, 6, 7])
print(arr10)
# Create a 2-dimensional array
arr11 = np.array([[1, 2], [3, 4]])
print(arr11)
# Append a row to the end of the array
arr11= np.append(arr11, [[5, 6]], axis=0)
print(arr11)
# Append a column to the end of the array
arr11 = np.append(arr11, [[7], [8], [9]], axis=1)
print(arr11)
### concatenate( )
> It is a function in the NumPy that concatenates (joins) two or more arrays along a specified axis.

# Create two 1-dimensional arrays
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# Concatenate the arrays along the 0th axis (i.e., vertically)
c = np.concatenate((a, b))
print(c)

# Create two 2-dimensional arrays
d = np.array([[1, 2], [3, 4]])
e = np.array([[5, 6], [7, 8]])

# Concatenate the arrays along the 0th axis (i.e., vertically)
f = np.concatenate((d, e), axis=0)
print(f)

# Concatenate the arrays along the 1st axis (i.e., horizontally)
g = np.concatenate((d, e), axis=1)
print(g)
### dtype
# dtype is an attribute in the NumPy that specifies the data type of the elements in a NumPy array

arr12 = np.array([1,2,3])
print(arr12.dtype)

# Create an array with dtype int32
arr13 = np.array([1, 2, 3], dtype=np.int32)
print(arr13.dtype)

# Create an array with dtype complex128
arr14 = np.array([1+2j, 3+4j, 5+6j], dtype=np.complex128)
print(arr14.dtype)
### shape, size, reshape
# shape is an attribute of a NumPy array that returns a tuple of integers representing the dimensions of the array

arr15= np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
print(arr15.shape)
# size is an attribute of a NumPy array that returns the number of elements in the array
print(arr15.size)
#reshape is a method of a NumPy array that returns a new array with the same data but a new shape.
arr15=arr15.reshape(2,2,3)
print(arr15)
### Indexing and Slicing Operations



> Indexing and slicing are operations that allow you to access and manipulate specific elements or parts of a NumPy array.
# Indexing is the process of accessing a single element of a NumPy array. 

print(arr15[1][1][1])
# Slicing is the process of accessing a portion of a NumPy array.

arr16=np.arange(10,60)

print(arr16[22:28])
arr16=arr16.reshape(25,2)
#print first 3 rows and two columns

print(arr16[:3,:2])
### sort( )
> It is a NumPy function that sorts elements of an array in ascending or descending order. 
```
numpy.sort(a, axis=-1, kind=None, order=None)
```
arr17=np.array([90,24,11,54,132,64,12,3])
#by default it's ascending order
arr17=np.sort(arr17)
print(arr17)
#sort array in descending order

print(np.sort(arr17)[::-1])
## Random



> The random module provides various functions for generating random numbers with different distributions, including uniform, normal, and exponential distributions.


# random is a NumPy module that provides function for generating pseudo random numbers.

# Generate a random integer between 0 and 9
random_int = np.random.randint(10)
print(random_int)
# Generate a random float between 0 and 1
random_float = np.random.rand()
print(random_float)
# Generate an array of 10 random integers between 0 and 9
random_ints = np.random.randint(10, size=10)
print(random_ints )
# Generate an array of 10 random floats between 0 and 1
random_floats = np.random.rand(10)
print(random_floats )
# Generate an array of 10 random numbers from a standard normal distribution
random_norm = np.random.randn(10)
print(random_norm)

> NumPy also provides other functions in the random module for generating random numbers with different distributions, such as beta(), binomial(), chisquare(), exponential(), f(), gamma(), geometric(), gumbel(), laplace(), logistic(), lognormal(), logseries(), multinomial(), multivariate_normal(), negative_binomial(), noncentral_chisquare(), noncentral_f(), normal(), pareto(), poisson(), power(), rayleigh(), shuffle(), standard_cauchy(), standard_exponential(), standard_gamma(), standard_normal(), standard_t(), triangular(), uniform(), vonmises(), wald(), weibull(), and zipf().
